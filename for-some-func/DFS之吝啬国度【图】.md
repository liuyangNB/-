## DFS之吝啬国度【图】

描述
在一个吝啬的国度里有N个城市，这N个城市间只有N-1条路把这个N个城市连接起来。现在，Tom在第S号城市，他有张该国地图，他想知道如果自己要去参观第T号城市，必须经过的前一个城市是几号城市（假设你不走重复的路）。
输入
第一行输入一个整数M表示测试数据共有M(1<=M<=5)组
每组测试数据的第一行输入一个正整数N(1<=N<=100000)和一个正整数S(1<=S<=100000)，N表示城市的总个数，S表示参观者所在城市的编号
随后的N-1行，每行有两个正整数a,b(1<=a,b<=N)，表示第a号城市和第b号城市之间有一条路连通。
输出
每组测试数据输N个正整数，其中，第i个数表示从S走到i号城市，必须要经过的上一个城市的编号。（其中i=S时，请输出-1）
样例输入
>1
10 1
1 9
1 8
8 10
10 3
8 6
1 2
10 4
9 5
3 7

样例输出

>-1 1 10 10 9 8 3 1 1 8

【解题思路】

图的深搜，遍历每一个城市，**记得做好标记**，因为N-1条路连N个城市证明图是连通的，从任一顶点进入搜索肯定能遍历所有顶点的，只需要把遍历的前一顶点在数组中记录下来最后输出数组即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v[100005];
int vis[100005],c[100005];
int dfs(int s)
{
    //因为map是vector构建的邻接矩阵，所以从s城市开始，遍历s城市能够到达的所有城市，有v[s].size()个，其中这条路上第i个用i表示
    //遍历是遍历所有可能，记录是记录满足要求的可能
	for(int i=0;i<v[s].size();i++){
		int x=v[s][i];//s城市开始的第i个城市编号x
		if(!vis[x]){
			vis[x]=1;
			//printf("v[%d][%d]=%d\n",s,i,x);
			c[x]=s;//这个城市x没有访问过，那就记录，s的下一步是x；
			dfs(x);//跳到x城市进行深搜
		}
	}
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--){
		memset(vis,0,sizeof(vis));
		memset(c,0,sizeof(c));
		for(int i=0;i<100005;i++)v[i].clear();
		int n,s,a,b;
		scanf("%d%d",&n,&s);
		int k=n-1;
        //构图map[a]=b;map[b]=a;
		while(k--){
			scanf("%d%d",&a,&b);
			v[a].push_back(b);
			v[b].push_back(a);
		}
		dfs(s);
		c[s]=-1;
		printf("%d",c[1]);
		for(int i=2;i<=n;i++)printf(" %d",c[i]);
		printf("\n");
	}
	return 0;
}
--------------------- 

```

