# 第一章 快速上手

## 1.1简介

一堆废话先过

### 1.1.1空白和注释

```cpp
//
/**/
#if debug
	STATMENT
#endif
```

### 1.1.2预处理

头文件：

```cpp
include <iostram>//引用的是编译器的类库路径里面的头文件。
#include "stdio.h"//引用的是你程序目录的相对路径中的头文件。
    如果使用" "，它是会先在你项目的当前目录查找是否有对应头文件
如果没有，它还是会在对应的引用目录里面查找对应的头文件
```

宏定义：

```cpp
#define MAX 200
在菊厂实习时候看屎山有好多宏定义的函数，需要深入了解下
```

### 1.1.3 main函数

讲了案例里的一些基础的东西。参数的三种传递方式；printf的格式化输出%d %o %x;字符串常量最后是加上了null（C语言并不存在string类型，字符串常量就是一串以NUL字节结尾的字符）

### 1.1.4 fun()函数

就讲了例子里的一个函数以及注意点。

```cpp
while(num < max && scanf("%d",&arr[num])==1 && arr[num]>=0){...}
/*注意点*/
scanf中的&,一般标量是要加&；数组参数不用加；数组参数中出现下标引用，也就是说实际参数是数组的某个特定元素，这时候也要加&。之后15章细讲
```

```cpp
if( num%2 !=0){
    exit( EXIT_FAILURE);
}
/*注意点*/
exit的终止程序运行机制
```

```cpp
while( (ch = getchar())!= EOF && ch!= '\n'){...}
/*注意点*/
getchar()读字节，回车、空格、换行、EOF（？？？）等都会读到，有时候用来读行时候吃回车
```

## 1.2补充说明

strcpy和strncpy()

```cpp
//C语言标准库函数strcpy的一种典型的工业级的最简实现。头文件string.h
//返回值：目标串的地址。
//对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。 
//参数：des为目标字符串，source为原字符串。
char* strcpy(char* des,const char* source)
```

strchr

```cpp
#include <string.h>
char *strchr(const char *str, int c)
 /*
在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置。
返回值:该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL
 */   
```

## 1.3编译

`第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。[.c]`

`第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。[.i(.ii)]`

`第三步，汇编。将第二步产生的汇编源码转换为 object file  [.o]`

`第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。[exe]`

`可以再深入了解下四个过程的细节，CSAPP`

## 1.4

总结.....

## 1.5警告的总结

scanf的&

&& 与 &

== 与 =

# 第二章 基本概念（略）

2.1环境

2.2词法

2.3程序风格

# 第三章数据

## 3.1基本数据类型

整形、浮点型、指针和聚合类型。

### 3.1.1整型家族

char 	int 	long 	long long 

C语言只规定short <= int <=long int。具体还得看具体的[编译器](https://baike.baidu.com/item/编译器)，long int型并不能肯定就是64位的，很多时候long int和int表示的范围是一致的。

头文件limits.h

>SCHAR_MIN	SCHAR_MAX	UCHAR_MAX

> SHRT_MIN	SHRT_MAX	USHRT_MAX

> INT_MIN	INT_MAX	UINT_MAX

> LONG_MIN	LONG_MAX	LONG_MAX

移植性的问题要综合考虑了，比如有些机器处理unsigned char 比较好，而有些则处理char比较好，那么就尽量把char类型的值限定在两者之间的范围。

一、整型字面值

12十进制	012八进制	0x12十六进制	'M'字符常量	L'X'宽字符常量

'\60'(也是表示ASCII码)

value = value - 48;	value = value -\60;	value = value - '0';//三者含义一样

二、枚举类型

enum Jar_Type{A,B,C=4,D,E};//A=0;B=1;C=4;D=5;E=6

### 3.1.2浮点类型

double lf	float f

6.023e23

### 3.1.3指针

一、指针常量 int* const p = &a; 

指针是常量

二、字符串常量

以NUL字符结尾的零个或多个字符，(""空字符串也是以NUL结尾的)

字符串常量可以直接幅值给一个“指向字符的指针”，但是不能直接幅值给一个字符数组。

## 3.2基本声明

Type  name1,name2...;

### 3.2.1初始化

int i = 15; 

extern int i;//声明 .bss

extern int i = 15;//初始化 .data

### 3.2.2声明简单数组

int arr[10];

列表初始化可以不写维度让编译器自己计算：int arr[]={1,2,3}

如果指明维度就不能超过：char arr[4] = "abcd";//报错，溢出

### 3.2.3声明指针

int* a,b,c;//只有a是指针，不可传递

char* message = "hello";

## 3.3 typedef

定义类型新名字：注意指针部分！

char* name;	=>typedef char* p1; 不同于#define p2 char*

p1 a,b,c;//abc都在char*

p2 a,b,c; 等同于 char* a,b,c; 只有a是指针

对于函数指针类型：typedef 	int* (\*)(int a,int b)	p_fun;//需要什么类型写一遍，然后去掉变量名称就好了(我自己的理解)

## 3.4常量

int const a = 15;//const int a = 15相同

int const *p; //指向整型常量的指针，常量指针，所指对象是常量

int* const p;//指向整型的 **常量指针**，指针是常量，所指对象是int

## 3.5作用域

编译器可以确认4种不同类型的作用域：文件作用域、函数作用域、代码块作用域、原型作用域。

### 3.5.1代码块作用域

位于一对花括号之间的所有语句称为一个代码块；函数定义的形参也在代码块作用域。嵌套的各管各的，如果内外有重名，内部的会屏蔽外部的。外层的无法访问内层的，内层不能访问外层的要注意。（两个代码块不能同时存在）

### 3.5.2文件作用域

  任何在所有代码块之外申明的标识符都具有文件作用域；表明这些标识符从他们声明之处到他们所在的源文件结尾处都能访问。（全局变量？）

函数名不属于任何代码块，所以在文件中定义的函数也属于文件作用域。

#include 的头文件相对于嵌入到调用的地方，因此其.h文件的作用域不是本身文件结束的地方，而应该是调用其文件的结束处

### 3.5.3原型作用域

只适用于在函数原型中声明的参数名。注意，函数的声明不是函数定义。

### 3.5.4函数作用域

只适用于语句标签，语句标签用于goto（一个函数语句中所有的语句标签都必须唯一）//不懂，反正不是字面意思？

## 3.6连接属性

一个程序是连接各个文件的编译结果后才能形成的。所有的目标文件以及那些一个或者多个函数库引用的函数链接在一起，形成可执行文件；然后如果相同的标识符出现在不同的文件咋办？这时候标识符的链接属性决定如何处理不同文件中的标识符。标识符的作用与他的链接属性有关，但是这两个属性并不相同。

连接属性：extern(外部的)	intern(内部)	none(无)

**none**:总是被当成独立个体，多个声明也被当成独立的。

**intern**：在同一源文件内的所有声明指同一实体；但不同文件则是不同实体。

**extern**: 不论声明多少次、位于几个源文件都表示同一实体。

举例：

```cpp
typedef char* a;
int b;
int c(int d){
    int e;
    int f(int g);
    ...
}
/*****************/
b c f 链接属性是extern，其余为none;
其他文件声明b 调用c 实体都是这个文件的。这里f之所以是extern，因为他是函数，这个文件调用函数f，实际上是链接到其他文件他定义的地方。

```

修改链接属性：static、extern

如上述的变量b，如果改为 static int b;那就变成了internal属性。把函数定义为static那就可以防止被外部文件访问了。注意：**static只能改变链接属性是extern的声明，对于变量e加上static是没有用的；这样就使其变成静态变量了！！！！**

extern指定的标识符，说明可以访问其他文件定义的这个标识符实体。

extern修饰第一次声明的标识符，当不是修饰第一次声明的标识符，并不会改变第一次声明所指定的连接属性

```cpp
static int i;
int fun(){
    extern int i;//这个原理是none，现在加上extern也不会改变外面的i的连接属性。
}
```

## 3.7存储类型

有三个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。

**static**:变量缺省的存储类型取决于声明的位置；代码块之外声明的变量总是存储于静态代码块，称为静态变量；对于这类变量你无法为其指定其他存储类型，因为其是在运行前创建的。

**auto**:代码块内的变量缺省的存储类型是auto；也就是局部变量；但是如果在代码块内加上修饰符static（不同于前面链接属性在全局区加上static），那么变量就变成静态变量了。==**注意：加上static并不改变变量的作用域！！！**==

**register**,适用于高频使用的变量。

**初始化**：

自动变量和静态变量的初始化有一个重要差别，静态变量一开始就会把初始化的值存入，如果没有初始化会自动置0；自动变量因为要在运行时才能分配内存，所以没有缺省的初始值，显式的初始化只是看上去初始化，其会在代码块的起始处插入一条隐式的赋值语句。

导致：局部变量的初始化，除非加上const，不然并没效率提高，初始化与否只是风格差别；每次执行到代码块都会重新初始化，除非显示初始化，不然自动变量创建时其值都是垃圾。

**static关键词**

1、作为函数定义时，或用于代码块之外变量的声明时：static用于修改链接属性，extern变为intern；但是存储类型和作用域都不变。这种方式声明的函数名和变量只能自己的源文件使用。

2、代码块内部的static，用于改变存储类型，局部变量（自动变量）变为静态变量；但是链接属性和作用域不变。

## 3.9作用域、存储类型示例

```cpp
//静态变量，堆栈；作用域一直到程序结束，同名代码块声明后内除外
int a = 5;
//静态变量，堆栈；作用域一直到程序结束，同名代码块声明后内除外
extern int b;
//静态变量，堆栈；作用域一直到程序结束，同名代码块声明后内除外
static int c;
//e没有链接属性，局部变量;理论作用域包括整个函数，但是局部同名的局部变量冲突，局部变量申明开始会屏蔽外层的e。
int d(int e){//外部链接属性、作用域到文件结束
    int f = 15;
    register int b;
    static int b;
    extern int a;//这个声明并不需要，因为还在第一个a的作用域内
    {
        int e;//局部，不具链接属性
        int a;//局部，不具链接属性；
        extern int h;//全局变量，在静态内存，外部链接属性
    }
    ...
    {
        int x;
        int e;
    }
}
//作用域从定义开处生效
static int i(){
	...
}
```

总结：作用域有冲突就各自为政。链接属性不同于存储类型

## 3.10总结

具有external链接属性的实体称为全局变量，只要变量并非声明于代码块或者函数定义内部，其他缺省情况其连接属性是external；一个变量声明于代码块内部，在其前面添加extern关键字将使其引用的是全局变量。

具有external链接属性的实体总是具有静态存储类型；局部变量由函数内部使用，不能被其他函数通过名字引用；缺省情况存储类型是auto.

# 第四章 语句

```cpp
switch(expression){
    case 1:
    case 2:
    case 3:
        statement-list
        break;
    case 4:
    default:
}
```

# 第五章 操作符和表达式

## 5.1操作符

### 5.1.1算术操作符

\+ 	\- 	\*	/	%	

### 5.1.2位移操作符

\>>	<< 

注意：无符号值执行的所以位移操作都是逻辑位移（补0）；但是对于有符号的是算术位移还是逻辑位移要看编译器；

警告：

a<<-5;是左移-5？右移5？在某台计算机上可能表示左移27位（32位机）；这要看编译器了，所以要避免这样的操作。

### 5.1.3位操作符

&	|	^

位的操作：

value	=	value	|	1<<bit_num;	//或1置1

value	=	value	&~(1<<bit_num);//与非1置0

### 5.1.4赋值

a=x=y+3;//注意截短

```cpp
char ch;
while((ch=getchar())!=EOF){...}
/*********/
有截短，EOF比char长；这是个错误的代码示范。
应该：
while(!feof(fpin)){...}
while(scanf("%d",&n)!=EOF){...}

```

### 5.1.5单目操作符

！	++	-	&	sizeof	~	--	+	*	(强转类型)

> ！：逻辑取反，true~false			~：取补
>
> sizeof(): 字节长度。字节！字节！字节！
>
> c=++a;//c等于加后的a
>
> c=a++;//c等于加前的a

### 5.1.6关系操作符

\>	\<	>=	<=	==	!=

注意 =	==

### 5.1.7逻辑操作符

&&	||	！

### 5.1.8条件操作符

(a>5)?(0):(1);

c++和C还是有区别，c中不能做左值

### 5.1.9逗号运算符

自左向右依次运算:	if(b+1, c/2, d>0)

尽量不用吧

### 5.1.10下标引用、函数调用和结构成员（之后细讲）

arr[下标]	=	*(arr+(下标))

## 5.2布尔值

c并不显式具备布尔值，而是用整数代替。

## 5.3左值右值

a=b+25;

a是个左值，标识了这是可以存储结果的地方，标识机器中内存一个位置

b+25是右值，指定了一个值

## 5.4表达式求值

5.4.1隐式类型转换

5.4.2算术转换

int a = 50000;

int b = 60000;

long c = a*b;//溢出；因为a\*b是以int型计算的，返回的也是int；

long d = (long)a\*b;

5.4.3-4优先级和求值顺序

# 第六章 指针

## 6.1内存和地址

指针大小：一个32位机，指针大小是32位，也就是寻址长度32位；4字节。

## 6.2值和类型

float 4字节	int 4字节	double 8字节

**大端小端：**

> 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
>
> **小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中**
>
> 下面以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value
>
> **Big-Endian: 低地址存放高位，如下：**
>
> 高地址
> ---------------
> 　　buf[3] (0x78) -- 低位
> 　　buf[2] (0x56)
> 　　buf[1] (0x34)
> 　　buf[0] (0x12) -- 高位
> ---------------
> 　　低地址
>
> **Little-Endian: 低地址存放低位，如下：**
>
> 高地址
> ---------------
> 　　buf[3] (0x12) -- 高位
> 　　buf[2] (0x34)
> 　　buf[1] (0x56)
> 　　buf[0] (0x78) -- 低位
> --------------
>
> 低地址

注意：struct中一个个的类型不同的顺序，在内存中是按顺序编排的，具体到其各个类型的编排顺序再考虑大小端；以小端为例：

```cpp
struct node{
    int a;
    double b;
};
node n=*input;//模仿结构体读传感器传来的数据；
假设输入的数据是 01 02 03 04 05 06 07 08 09 10 11 12
传到node的内存中是：
【0x01020304】【0x0506070809101112】
低地址--------------------高地址
01 02 03 04   05 06 --- 12
 记住：小端是低地址低位；而以前搞混是搞错0x01020304中04才是低位！！
```

## 6.3指针变量的内容

int* a = &b;	&是取值操作，取b的地址付给a；a知道了地址，然后类型是int型指针，就按int大小对地址b操作。

## 6.4间接操作符

\*解引用

## 6.5未初始化和非法的指针

**典型错误**：

```cpp
int* a;//缺省值随机，可能是非法区，导致后面赋值出错；野指针
...
*a =12;
```

## 6.6空指针 (NULL)和野指针

空指针：

>  **空指针不指向任何实际的对象或者函数。**反过来说，任何对象或者函数的地址都不可能是空指针。
>
> 空指针是一个特殊的指针，因为这个指针不指向任何地方。这意味任何一个有效的指针如果和空指针进行相等的比较运算时，结果都是false。

> **int** *ip = NULL;  

野指针：

> **野指针不是空指针，是一个指向垃圾内存的指针。**
>
> 形成原因:
>
> **1.指针变量没有被初始化**
>
> ```cpp
> char* p ;  
> char* str; 
> /*********改为*************/
> char* p = NULL;  
> char* str = (char*)malloc(1024); 
> ```
>
> #### 2.指针被free或者delete之后，没有设置为NULL，让人误以为这是一个合法指针。
>
> ```cpp
> free(str);
> /****应该加上******/
> str=NULL;
> ```
>
> **3.指针操作超越了变量的作用范围。**
>
> ```cpp
> 由于C/C++中指针有++操作，因而在执行该操作的时候，稍有不慎，就容易指针访问越界，访问了一个不该访问的内存，结果程序崩溃。另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针
> A *p; // A为一个自定义对象  
> {  
>     A a;  
>     p = &a; // 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数  
>  }  
>  p->Func();  // p是“野指针”
> ```

## 6.7指针、间接访问和左值

指针变量能作为左值不是因为他们是指针，而是因为他们是变量。

*a = 10 - \*b;

## 6.8指针、间接访问和变量

*&a = 10;

什么意思？其实就是a=10; 这部分没啥意义

## 6.9指针常量

*100 = 25;你以位是在给地址是100这个地方赋值25；其实你是错的，因为100是整型，而不是指针类型；\*(int\*)100 = 25;这是可以的，但是这样做一般不用，在硬件中可能会这样干。

## 6.10指针的指针

char**p=NULL;

## 6.11指针表达式

char ch = 'a';	char* cp = &ch;

> &ch	可右值	左非法
>
> cp		可右		可左
>
> &cp	可右		左非法
>
> *cp		可右		可左
>
> *cp+1	可右		左非法	//(\*cp)+1
>
> \*(cp+1)	可右		可左
>
> ++cp		可右		左非法	//	cp和返回值都是指向下一个位置
>
> cp++		可右		左非法	//cp指向下一位置；返回值还是原理位置
>
> *++cp		可右		可左	//\*(++cp)
>
> *cp++		可右		可左	//右值是cp指向下一个位置，解引用之前的位置
>
> ++*cp		可右		左非法//cp所指值的前置++
>
> 后面几个看书吧，没啥意义P104



## 6.12实例（略）

## 6.13指针运算

根据指针类型决定运算时候的数字是几个字节反正看指针类型咯

关系运算中 标准运行指向数组元素的指针与指向数组最后一个元素后面的那个内存地址的指针比较，但是不能和第一个元素位置前面的地址的指针进行比较。

# 第七章 函数

## 7.1函数定义

int* fun();//旧式风格声明

int* fun(void)

## 7.3函数的参数

数组作为参数其实就是一个指针，数组长度需要输入。（之后数组章细讲）

值传递和指针传递的swap问题。

## 7.5递归

递归本身就算一层循环？看看DFS的总结

递归需要两个特性：存在限制条件(**出口**)、每次递归后越来越接近限定条件（**收敛**）

尾递归可以转换为迭代。写出迭代更新关系式：

fun(n)=fun(n-1)+fun(n-2)  

new	=cur+pre; 	pre = cur; 	cur = new;

## 7.6可变参数列表

#include<stdarg.h>

**va_list** 
这是一个适用于 **va_start()、va_arg()** 和 **va_end()** 这三个宏存储信息的类型

```cpp
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

void tLog(char *sInfo, ...);

int main(int argc, char *argv[])
{
    char str[4+1] = {0};
    strcpy(str,"INFO");
    tLog(str,argv[1],argv[2],argv[3]);
    return 0;
}
void tLog(char *sInfo, ...)
{
    char *str   = NULL;
    char *str1 = NULL;
    char *str2 = NULL;
    va_list sArgv;          // 申请参数列表变量
    va_start(sArgv, sInfo); // 申明最后一个传递给函数的已知的固定参数
    /* 依次读取固定参数 sInfo 后的 参数 */
    str   = va_arg(sArgv, char*);
    str1 = va_arg(sArgv, char*);
    str2 = va_arg(sArgv, char*);
    va_end(sArgv);
    printf("运行输出：[%s,%s%s%s]\n",sInfo,str,str1,str2);
}
```

说明：按序访问、可半途中止

# 第八章 数组

## 8.1一维数组

### 8.1.1数组名

int arr[10];

> 数组名的值是一个指针常量 arr \~~ int \*const p;但是不能说数组就是指针
>
> 只有数组名在表达式中使用时编译器才将其视为指针常量。

只有两个场景数组名并不是用指针常量来表示：

1、sizeof(arr);这里返回的是数组整个的字节数，而不是一个指针的长度。

2、取址&操作时候，scanf中如果数组有[]下标，需要&。

注意：

int* arr[10];

int* brr[10];

int* c;

c=a;//c只是一个数组指向arr第一个元素

brr=arr;//这也不是拷贝数组！！！拷贝数组需要循环

arr=c;这是不可以的，因为arr有const特性。

### 8.1.2下标引用

arr[i]	=>	\*(arr+(i))

### 8.1.5数组和指针

如何去理解清楚数组和指针？int arr[5];数组的长度是要确定的值，不能是变量，因为编译期间就得知道其大小，好分配内存。

int a[5];

int \*b;

上述声明后，表达式：*a是合法的，是数组第一个元素的解引用；\*b是不合法的，因为这将访问内存中不确定的地方。

但是，a++是不行的，b++是可以通过编译的。

### 8.1.6作为函数参数的数组名

拷贝指针咯，然后这个指针间接去修改数组内容。但是不会修改数组名这个指针。

### 8.1.7声明数组参数

函数的形参应该怎么样?

int fun(char* string){}

int fun(char string[]){}

两者一样，但是也只是当前上下文一样，函数并不会为数组形参开辟内存，这里的string[]本质上也只是char*;sizeof并不会得到数组的长度，要得到数组的长度就必须要显式传入参数。

### 8.1.8初始化

int arr[5]={1,2,3,4,5};	对于全局变量是真正意义初始化，在局部的自动变量本质上是赋值，因为每次到这的内存可能不同，除非声明为static。

int arr[5]={1,2,3,4,5,6};//报错，超出

int arr[5]={1,2,3};//ok，补0；

int arr[]={1,2,3,4,5,6,7};//自动计算长度。



char message[]={'h','e','e','l','o'};//这样当然可以，但是很呆

char message[]="hello";//看上去是字符串，其实是上面那种初始化的另一种写法。



char arr[]="hello";//字符数组

==char* message="hello";//字符串常量（C++中应是char \*const message = "hello";)==

## 8.2多维数组

int arr\[3][6]; 3行6列内存上是3个int [6]; \[]\[]\[]\[]\[]\[] \[][]\[][]\[][] \[][]\[][]\[][];

### 8.2.2数组名

arr 是指向数组的指针，指向的数组是int [6]类型。这个概念是后来的。

### 8.2.3下标

arr\[1][5]==\*((*(arr)+1)+5)\==\*(arr[1]+5)

### 8.2.4指向数组的指针

int arr[10]; 	int \* vp;	vp=arr;//ok没问题

int arr\[3][10], \*mp = arr;//有问题，因为arr是指针，但是指针类型是int [10]; 而mp指针类型是int*；

咋么办？ int (\*p)[10]; p=arr;这就可以了咯；这个p是一行一行调。

但是需要指针逐个访问二维数组元素咋么办？

int* pi  =&arr\[0][0];

int* pi = arr[0];//也可以

