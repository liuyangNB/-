# 面经总结

## 一、基本语言

### 1 ==static==关键字作用(链接属性、存储类型)

**1. 全局静态变量**

> ~在**全局变量前加上关键字static**，全局变量就定义成一个全局静态变量.~
>
> ~静态存储区，在整个程序运行期间一直存在。~
>
> ~初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；~
>
> ~作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。~

**2.局部静态变量**

> ~在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。~
>
> ~内存中的位置：静态存储区~
>
> ~初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；~
>
> ~作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；~

**3. 静态函数**

> ~在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。~
>
> ~函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；~
>
> ~warning：不要再头文件中声明static的全局函数(头文件是给其他文件用的，链接属性应该放extern的声明)，不要在cpp内声明非static的全局函数（cpp文件用写函数定义，extern的函数不要在这声明，static的函数声明不要放头文件就放cpp），如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；~

**4. 类的静态成员**

>  ==在类中，静态成员可以实现多个对象之间的数据共享==，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。**对多个对象来说，静态数据成员只存储一处，供所有对象共用**

**5. 类的静态函数**

> 静态成员函数和静态数据成员一样，它们都**属于类**的静态成员，它们都不是对象成员。因此，对静态成员的**引用不需要用对象名**。

### 2 说一下==C++和C的区别==

**设计思想上：**

> C++是面向对象的语言，而C是面向过程的结构化编程语言

**语法上：**

> C++具有封装、继承和多态三种特性
>
> C++相比C，增加多许多类型安全的功能，比如强制类型转换、
>
> C++支持范式编程，比如模板类、函数模板等

**具体细节：**

> **C89标准的C语言不支持函数默认值，C++支持函数默认值，且需要遵循从右向左赋初始值。** int  fun(int a ,int b = 10);
>
> **C语言不存在函数重载，C++根据函数名参数个数参数类型判断重载，属于静多态，必须同一作用域下才叫重载。**
>
> > 静多态：函数重载，函数模板
>
> > 动多态（运行时的多态）：继承中的多态（虚函数）。
>
> **C中的const叫只读变量，只是无法做左值的变量；C++中的const是真正的常量，但也有可能退化成c语言的常量，默认生成local符号。**
>
> **引用底层就是指针，使用时会直接解引用，可以配合const对一个立即数进行引用。**

### 3、c++中四种==cast转换==

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

1、const_cast

> 用于将const变量转为非const

2、static_cast(类比C中常规强转)

> ==用于各种隐式转换==，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

3、dynamic_cast

> 用于动态类型转换。==只能用于含有虚函数的类，==用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
>
> 向上转换：指的是子类向基类的转换
>
> 向下转换：指的是基类向子类的转换
>
> 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、reinterpret_cast

> 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

5、为什么不使用C的强制转换？

> C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

### 4、C/C++ 中==指针==和==引用==的区别？

> 1.指针有自己的一块**空间**，而引用只是一个别名；
>
> 2.使用**sizeof**看一个指针的大小是4，而引用则是被引用对象的大小；
>
> 3.指针可以被**初始化**为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
>
> 4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
>
> 5.可以有**const**指针，但是没有const引用；(引用常量不存在，没有int& const p，常量引用是存在的cosnt int &p)
>
> 6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被**改变**；
>
> 7.指针可以有多级指针（**p），而引用至于一级；
>
> 8.指针和引用使用++运算符的意义不一样；
>
> 9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

### 5、C++中的==智能指针==

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, **unique_ptr** 其中后三个是c++11支持，并且第一个已经被11弃用

weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,

为什么要使用智能指针：

> 智能指针的作用是管理一个指针，因为存在以下这种情况：**申请的空间在函数结束时忘记释放，造成内存泄漏**。使用智能指针可以很大程度上的避免这个问题，因为**智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数**，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

### 6、==数组==和==指针==的区别

> 数组：数组是**用于储存多个相同类型数据的集合**。
>
> 指针：指针相当于一个**变量**，但是它和不同变量不一样，它存放的**是其它变量在内存中的地址**。
>
> 区别：
>
> •    **赋值**：同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝
>
> •    **存储方式**：数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。
>
> •    **求sizeof**：数组所占存储空间的内存：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）。在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。
>
> •    初始化方式不同。
>
> •    **传参方式**：数组传参时，会退化为指针，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。一级指针传参可以接受的参数类型：（1）可以是一个整形指针 （2）可以是整型变量地址 （3）可以是一维整型数组数组名；当函数参数部分是二级指针时，可以接受的参数类型：（1）二级指针变量（2）一级指针变量地址（3）一维指针数组的数组名

### 7、为什么==析构函数必须是虚函数==？为什么C++默认的析构函数不是虚函数

> 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，**防止内存泄漏**。



> C++默认的析构函数不是虚函数是**因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存**。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 8、析构函数的作用

1. 作用：对象消亡时，自动被调用，用来释放对象占用的空间 
2. 特点:    (1) 名字与类名相同    (2) 在前面需要加上"~"    (3) 无参数，无返回值    (4) 一个类最多只有一个析构函数    (5) 不显示定义析构函数会调用缺省析构函数

### 9、你理解的==虚函数==和==多态==

> 多态的实现主要分为**静态多态**和**动态多态**，静态多态主要是==重载==，在编译的时候就已经确定；动态多态是用==虚函数机制==实现的，在运行期间动态绑定。
>
> 举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### 10 new/delete与malloc/free的区别是什么

> 首先，new/delete是**C++的关键字**，而malloc/free是**C语言的库函数**，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

## 二 容器和算法

### 1 map和set的区别，实现方式？

> map和set都是C++的关联容器，其**底层实现都是红黑树**（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。
>
> map和set区别在于：
>
> （1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
>
> （2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。**其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，**不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。
>
> （3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。

### 2 STL迭代器删除元素

> 这个主要考察的是==迭代器失效的问题==。
>
> 1.对于**序列容器**vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
>
> 2.对于**关联容器**map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
>
> 3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

### 3 STL中map与unordered_map

1、Map

映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。

底层实现：红黑树

适用场景：有序键值对不重复映射

2、Multimap

多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。

底层实现：红黑树

适用场景：有序键值对可重复映射

### 4 vector和list的区别，应用，越详细越好

> 1）Vector
>
> **连续存储**的容器，**动态数组**，在**堆**上分配空间
>
> 底层实现：数组
>
> 两倍容量增长：
>
> vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。
>
> **如果没有剩余空间了**，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。
>
> 性能：
>
> 访问：O(1)
>
> 插入：在最后插入（空间够）：很快;中间慢
>
> 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。
>
> 2、List
>
> **动态链表**，在**堆上**分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。
>
> 底层：双向链表
>
> 性能：
>
> 访问：随机访问性能很差，只能快速访问头尾节点。
>
> 插入：很快，一般是常数开销
>
> 删除：很快，一般是常数开销
>
> 适用场景：经常插入删除大量数据
>
> 3、应用
>
> vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。
>
> list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

### 5 STL中迭代器的作用，有指针为何还要迭代器

> 1、迭代器
>
> Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。
>
> 2、迭代器和指针的区别
>
> 迭代器不是指针，**是类模板，表现的像指针**。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
>
> 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。
>
> 3、迭代器产生原因
>
> Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

### 6 C++中struct和class的区别

> 在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。
>
> 但是C中的struct是不同的，函数就不能在C中的struct。
